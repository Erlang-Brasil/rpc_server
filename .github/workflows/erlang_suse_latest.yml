name: Erlang CI com OpenSUSE Latest Otimizado

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

permissions:
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest

    container:
      image: opensuse/tumbleweed:latest

    steps:
    - name: Checkout código
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Adicionado para buscar todo o histórico

    # PASSO DE INSTALAÇÃO MOVIDO PARA ANTES DO DEBUG DO CHECKOUT
    - name: Instalar dependências do sistema e Erlang
      id: setup_erlang
      run: |
        zypper refresh
        # Adicionado findutils para o comando find
        zypper install -y erlang git wget bash which findutils # git é instalado aqui
        echo "Verificando presença do bash:"
        which bash
        ls -l /bin/bash
        echo "Verificando presença do git:"
        which git
        git --version
        echo "Verificando presença do find:"
        which find
        echo "ERLANG_OTP_RELEASE=$(erl -noshell -eval 'erlang:display(erlang:system_info(otp_release)), halt().' | tr -d '"')" >> $GITHUB_OUTPUT
        echo "Versão do Erlang/OTP instalada:"
        erl -version
      shell: bash

    # AGORA O DEBUG DO CHECKOUT PODE USAR O GIT
    - name: Debug Verificar Checkout Inicial
      run: |
        echo "Diretório atual: $(pwd)"
        echo "Variável GITHUB_WORKSPACE: $GITHUB_WORKSPACE"
        echo "Listando conteúdo do diretório atual ($GITHUB_WORKSPACE):"
        ls -la
        echo "---"
        echo "Verificando se .git existe em $(pwd)/.git:"
        if [ -d ".git" ]; then
          echo ".git encontrado em $(pwd)/.git"
          ls -la .git
        else
          echo ".git NÃO encontrado em $(pwd)/.git"
        fi
        echo "---"
        echo "Tentando encontrar diretórios .git a partir de /__w:"
        find /__w -name ".git" -type d -ls 2>/dev/null || echo "Nenhum diretório .git encontrado via find em /__w"
        echo "---"
        echo "Saída do git status:"
        git status || echo "git status falhou"
        echo "---"
        echo "Saída do git rev-parse --is-inside-work-tree:"
        git rev-parse --is-inside-work-tree || echo "git rev-parse --is-inside-work-tree falhou"
        echo "---"
        echo "Saída do git rev-parse --git-dir:"
        git rev-parse --git-dir || echo "git rev-parse --git-dir falhou"
        echo "---"
        echo "Saída do git rev-parse --show-toplevel:"
        git rev-parse --show-toplevel || echo "git rev-parse --show-toplevel falhou"
        echo "---"
        echo "Commit atual (git log):"
        git log -1 --pretty=%H%n%s || echo "git log falhou"
        echo "---"
        echo "Verificando o código fonte de src/shell/rpc_server_shell_instance.erl ANTES de qualquer compilação ou cache:"
        SOURCE_FILE_TO_CHECK="src/shell/rpc_server_shell_instance.erl"
        if [ -f "$SOURCE_FILE_TO_CHECK" ]; then
          cat "$SOURCE_FILE_TO_CHECK"
        else
          echo "Arquivo fonte $SOURCE_FILE_TO_CHECK não encontrado no checkout inicial."
        fi
      shell: bash

    - name: Configurar cache para Rebar3, dependências e _build
      id: cache_rebar_build
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/rebar3
        # Chave de cache atualizada para incluir hash dos arquivos .erl e .hrl
        key: ${{ runner.os }}-opensuse-erlang-${{ steps.setup_erlang.outputs.ERLANG_OTP_RELEASE }}-rebar-${{ hashFiles('**/rebar.lock') }}-${{ hashFiles('**/src/**/*.erl', '**/src/**/*.hrl', '**/include/**/*.hrl') }}
        restore-keys: |
          ${{ runner.os }}-opensuse-erlang-${{ steps.setup_erlang.outputs.ERLANG_OTP_RELEASE }}-rebar-${{ hashFiles('**/rebar.lock') }}-
          ${{ runner.os }}-opensuse-erlang-${{ steps.setup_erlang.outputs.ERLANG_OTP_RELEASE }}-rebar-
          ${{ runner.os }}-opensuse-erlang-
          ${{ runner.os }}-opensuse-

    - name: Instalar Rebar3 (se não estiver no cache) e configurar ENV var
      run: |
        REBAR3_VERSION="3.25.0" # Considere usar uma versão mais recente se disponível/necessário
        REBAR3_CACHE_BIN_DIR="$HOME/.cache/rebar3/bin"
        REBAR3_EXEC="$REBAR3_CACHE_BIN_DIR/rebar3"

        mkdir -p "$REBAR3_CACHE_BIN_DIR"

        if [ ! -f "$REBAR3_EXEC" ]; then
          echo "Rebar3 não encontrado em $REBAR3_EXEC. Instalando..."
          TEMP_WORK_DIR=$(mktemp -d)
          ORIGINAL_DIR=$(pwd)
          cd "$TEMP_WORK_DIR"
          echo "Baixando Rebar3 ($REBAR3_VERSION) para $TEMP_WORK_DIR/rebar3..."
          wget -q https://github.com/erlang/rebar3/releases/download/${REBAR3_VERSION}/rebar3 -O rebar3
          chmod +x rebar3
          echo "Executando './rebar3 local install' a partir de $TEMP_WORK_DIR..."
          ./rebar3 local install
          cd "$ORIGINAL_DIR"
          rm -rf "$TEMP_WORK_DIR"
          if [ ! -f "$REBAR3_EXEC" ]; then
            echo "ERRO CRÍTICO: Falha ao instalar o Rebar3 em $REBAR3_EXEC."
            exit 1
          fi
          echo "Rebar3 $REBAR3_VERSION instalado com sucesso em $REBAR3_EXEC."
        else
          echo "Rebar3 encontrado em $REBAR3_EXEC (provavelmente restaurado do cache)."
        fi
        echo "REBAR3_INSTALL_DIR=${REBAR3_CACHE_BIN_DIR}" >> $GITHUB_ENV
        echo "REBAR3_INSTALL_DIR configurado para: ${REBAR3_CACHE_BIN_DIR}"
        "$REBAR3_EXEC" --version
      shell: bash

    - name: Compilar projeto (incluindo dependências se não cacheadas)
      run: |
        export PATH="${REBAR3_INSTALL_DIR}:$PATH"
        echo "PATH atualizado no passo 'Compilar projeto': $PATH"
        which rebar3
        rebar3 --version
        echo "Limpando compilações anteriores..."
        rebar3 clean
        echo "Compilando o projeto..."
        rebar3 compile
      shell: bash

    - name: Debug Verificar arquivos e artefatos antes da analise
      run: |
        export PATH="${REBAR3_INSTALL_DIR}:$PATH"
        echo "PATH atualizado no passo 'Debug Verificar arquivos': $PATH"

        echo "Limpando compilações anteriores (novamente para garantir)..."
        rebar3 clean
        echo "Compilando o projeto (novamente para garantir artefatos frescos)..."
        rebar3 compile
        
        SOURCE_FILE="src/shell/rpc_server_shell_instance.erl"
        # Ajuste 'rpc_server' se o nome da sua aplicação OTP for diferente
        APP_NAME="rpc_server" 
        BEAM_FILE_DIR="_build/default/lib/${APP_NAME}/ebin"
        BEAM_FILE="${BEAM_FILE_DIR}/rpc_server_shell_instance.beam"
        MODULE_NAME="rpc_server_shell_instance"

        echo "Conteúdo de $SOURCE_FILE (após compilação neste passo):"
        if [ -f "$SOURCE_FILE" ]; then
          cat "$SOURCE_FILE"
        else
          echo "Arquivo fonte $SOURCE_FILE não encontrado."
        fi
        
        echo "Verificando BEAM file: $BEAM_FILE"
        if [ -d "$BEAM_FILE_DIR" ]; then
          echo "Listando conteúdo de $BEAM_FILE_DIR:"
          ls -la "$BEAM_FILE_DIR"
          if [ -f "$BEAM_FILE" ]; then
            echo "Detalhes do BEAM file ($BEAM_FILE) (timestamp, tamanho):"
            ls -l "$BEAM_FILE"
            echo "Verificando de onde o Erlang carregaria o módulo $MODULE_NAME:"
            erl -noshell -eval "io:format(\"code:which(~s) -> ~p~n\", [\"${MODULE_NAME}\", code:which(${MODULE_NAME})]), halt()." || echo "Falha ao verificar code:which"
          else
            echo "Arquivo BEAM $BEAM_FILE não encontrado no diretório $BEAM_FILE_DIR."
          fi
        else
          echo "Diretório de BEAM files $BEAM_FILE_DIR não encontrado."
        fi
      shell: bash

    - name: Executar análise estática (Xref e Dialyzer)
      run: |
        export PATH="${REBAR3_INSTALL_DIR}:$PATH"
        echo "PATH atualizado no passo 'Análise Estática': $PATH"
        
        echo "Executando rebar3 xref..."
        rebar3 xref
        XREF_STATUS=$?
        if [ $XREF_STATUS -ne 0 ]; then
          echo "rebar3 xref falhou com status $XREF_STATUS (ou emitiu avisos tratados como erros)"
          # Considerar sair se xref falhar e for crítico: exit $XREF_STATUS
        fi
        echo "rebar3 xref concluído."

        echo "Executando rebar3 dialyzer..."
        # Pode ser útil construir a PLT explicitamente se houver problemas, ex: rebar3 dialyzer build
        rebar3 dialyzer
        DIALYZER_STATUS=$?
        if [ $DIALYZER_STATUS -ne 0 ]; then
          echo "rebar3 dialyzer falhou com status $DIALYZER_STATUS"
          exit $DIALYZER_STATUS
        fi
        echo "rebar3 dialyzer concluído com sucesso."
      shell: bash

    - name: Rodar testes
      id: run_tests
      run: |
        export PATH="${REBAR3_INSTALL_DIR}:$PATH"
        echo "PATH atualizado no passo 'Rodar testes': $PATH"
        DIAGNOSTIC=1 rebar3 do eunit, ct
      shell: bash

    - name: Upload rebar3 crashdump (se houver falha nos testes)
      if: steps.run_tests.outcome == 'failure'
      uses: actions/upload-artifact@v4
      with:
        name: rebar3-crashdump-${{ runner.os }}-${{ steps.setup_erlang.outputs.ERLANG_OTP_RELEASE }}
        path: |
          rebar3.crashdump
          ./rebar3.crashdump
          _build/default/rebar3.crashdump
          _build/test/rebar3.crashdump
        if-no-files-found: ignore
