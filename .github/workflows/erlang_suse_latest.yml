name: Erlang CI Otimizado

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

permissions:
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: opensuse/tumbleweed:latest

    steps:
    - name: 1. Checkout do código
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Necessário para algumas análises e versionamento

    - name: 2. Instalar dependências do sistema e Erlang
      id: setup_erlang
      run: |
        zypper --non-interactive refresh
        zypper --non-interactive install -y erlang git wget bash which
        # Cria um output com a versão do OTP para usar na chave do cache
        echo "ERLANG_OTP_RELEASE=$(erl -noshell -eval 'erlang:display(erlang:system_info(otp_release)), halt().' | tr -d '"')" >> $GITHUB_OUTPUT
        echo "Versão do Erlang/OTP instalada: $(erl -version)"
      shell: bash

    - name: 3. Instalar Rebar3 (Última Versão)
      id: install_rebar3
      run: |
        # Busca dinamicamente a tag da última versão estável do Rebar3
        REBAR3_VERSION=$(wget -q -O- "https://api.github.com/repos/erlang/rebar3/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
        echo "Instalando Rebar3 versão: ${REBAR3_VERSION}"
        
        REBAR3_BIN_DIR="$HOME/.local/bin"
        mkdir -p "$REBAR3_BIN_DIR"
        
        wget -q https://github.com/erlang/rebar3/releases/download/${REBAR3_VERSION}/rebar3 -O "${REBAR3_BIN_DIR}/rebar3"
        chmod +x "${REBAR3_BIN_DIR}/rebar3"
        
        # Adiciona o diretório do Rebar3 ao PATH para todos os passos seguintes
        echo "${REBAR3_BIN_DIR}" >> $GITHUB_PATH
        
        echo "Rebar3 instalado em: $(which rebar3)"
        rebar3 --version
      shell: bash

    - name: 4. Configurar e Restaurar Cache
      id: cache
      uses: actions/cache@v4
      with:
        # Cacheia o diretório de build e o cache do rebar3 (que inclui o PLT do Dialyzer)
        path: |
          ~/.cache/rebar3
          _build
        # A chave de cache é invalidada se a versão do Erlang, SO, ou as dependências (rebar.lock) mudarem.
        key: ci-cache-${{ runner.os }}-${{ steps.setup_erlang.outputs.ERLANG_OTP_RELEASE }}-${{ hashFiles('**/rebar.lock') }}
        restore-keys: |
          ci-cache-${{ runner.os }}-${{ steps.setup_erlang.outputs.ERLANG_OTP_RELEASE }}-

    - name: 5. Compilar dependências e projeto
      id: compile
      run: |
        # Compila tudo uma única vez. Os artefatos serão usados pelos passos seguintes.
        rebar3 compile
      shell: bash

    - name: 6. Executar análise estática (Xref)
      id: xref
      run: |
        rebar3 xref
      shell: bash

    - name: 7. Executar análise de tipos (Dialyzer)
      id: dialyzer
      run: |
        # Se o cache foi restaurado com um PLT válido, este passo será muito rápido.
        # A variável DIAGNOSTIC=1 é mantida para obter logs detalhados em caso de falha.
        DIAGNOSTIC=1 rebar3 dialyzer
      shell: bash

    - name: 8. Rodar testes (EUnit e Common Test)
      id: tests
      run: |
        DIAGNOSTIC=1 rebar3 do eunit, ct
      shell: bash

    - name: 9. Upload de crashdump (em caso de falha)
      # Este passo executa se qualquer um dos passos anteriores falhar
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: rebar3-crashdump-${{ runner.os }}-${{ steps.setup_erlang.outputs.ERLANG_OTP_RELEASE }}
        path: |
          rebar3.crashdump
          ./rebar3.crashdump
          _build/default/rebar3.crashdump
          _build/test/rebar3.crashdump
        if-no-files-found: error # Use 'error' or 'warn' para saber se o arquivo não foi encontrado