name: Erlang CI on Ubuntu

on: [push, pull_request]

permissions:
  contents: read # Necessário para actions/checkout
  # checks: write # Pode ser necessário para actions de cobertura que atualizam status de PR
  # pull-requests: write # Pode ser necessário para actions de cobertura que comentam em PRs

jobs:
  build:
    runs-on: ubuntu-24.04 # Ou ubuntu-22.04 para LTS anterior
    strategy:
      matrix:
        otp: ['28.0','27.0', '26.2.2'] # Exemplo de matriz para testar em múltiplas versões OTP
        # Adicione outras variáveis de matriz se necessário (ex: rebar3_version)
    env:
      REBAR3_VERSION: '3.22.1' # Especifique a versão do Rebar3

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up BEAM
        uses: erlef/setup-beam@v1 # Usa a tag móvel v1.x.y recomendada
        id: setup-beam
        with:
          otp-version: ${{ matrix.otp }}
          rebar3-version: ${{ env.REBAR3_VERSION }}
          # version-type: strict # Descomente para correspondência exata de versão

      - name: Restore Hex package cache
        uses: actions/cache@v4
        id: hex-cache
        with:
          path: |
            ~/.cache/rebar3/hex
            ~/.hex
          key: ${{ runner.os }}-hex-${{ steps.setup-beam.outputs.otp-version }}-${{ hashFiles('**/rebar.lock') }}
          restore-keys: |
            ${{ runner.os }}-hex-${{ steps.setup-beam.outputs.otp-version }}-

      - name: Restore Dialyzer PLT cache
        uses: actions/cache@v4
        id: plt-cache
        with:
          path: |
            ~/.cache/rebar3/plt_*.ets # Cache global de PLTs base
            _build/default/rebar3_*.plt # Cache local de PLTs do projeto (ajuste o caminho se plt_location/plt_prefix for diferente)
          key: ${{ runner.os }}-plt-${{ steps.setup-beam.outputs.otp-version }}-${{ hashFiles('**/rebar.lock', '**/rebar.config') }}
          restore-keys: |
            ${{ runner.os }}-plt-${{ steps.setup-beam.outputs.otp-version }}-

      # Opcional: Cache para o diretório _build (pode ser grande e volátil)
      # - name: Restore _build cache
      #   uses: actions/cache@v4
      #   id: build-cache
      #   with:
      #     path: _build
      #     key: ${{ runner.os }}-build-${{ steps.setup-beam.outputs.otp-version }}-${{ hashFiles('**/rebar.lock', '**/rebar.config', 'apps/**/src/**/*.erl', 'src/**/*.erl') }}
      #   restore-keys: |
      #     ${{ runner.os }}-build-${{ steps.setup-beam.outputs.otp-version }}-

      - name: Install Dependencies
        # if: steps.hex-cache.outputs.cache-hit!= 'true' # Opcional: pular se o cache de dependências for restaurado
        run: rebar3 deps

      - name: Compile
        run: rebar3 compile

      - name: Run Dialyzer
        # Considerar executar sempre ou condicionar ao cache-hit da PLT.
        # A construção da PLT pode ser parte desta etapa se não estiver totalmente em cache.
        run: rebar3 dialyzer

     # - name: Run Linter (rebar3_lint with Elvis)
        # Adicione rebar3_lint aos plugins no rebar.config
        # run: rebar3 lint # Descomente se rebar3_lint estiver configurado

      - name: Run EUnit tests with coverage
        run: rebar3 eunit --cover

      - name: Run Common Test suites with coverage
        run: rebar3 ct --cover

      # Opção 1: Upload para Codecov usando rebar3_codecov plugin
      # Adicione rebar3_codecov aos plugins e provider_hooks no rebar.config
      # {plugins, [{rebar3_codecov, "0.4.0"}]}.
      # {provider_hooks, [{post, [{eunit, {codecov, analyze}}]}, {post, [{ct, {codecov, analyze}}]}]}.
      # {cover_enabled, true}.
      # - name: Analyze coverage for Codecov (using rebar3_codecov)
      #   run: rebar3 codecov analyze # Gera o JSON
      # - name: Upload coverage to Codecov (using rebar3_codecov)
      #   if: success() && matrix.otp == '27.0' # Exemplo: enviar apenas para uma versão OTP
      #   run: rebar3 codecov upload
      #   env:
      #     CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

      # Opção 2: Upload para Codecov usando codecov/codecov-action
      # Requer que um relatório em formato compatível (ex: LCOV, ou JSON do rebar3_codecov analyze) seja gerado.
      # Se rebar3_codecov analyze foi executado, o arquivo JSON estará em _build/test/codecov.json
      - name: Generate Codecov JSON report (using rebar3_codecov)
        if: always() # Executar mesmo se os testes falharem para ter o relatório
        run: |
          rebar3 as test codecov analyze |
          | echo "Codecov analysis failed but continuing to allow report upload"
        # Adicione rebar3_codecov aos plugins e provider_hooks no rebar.config
        # {plugins, [{rebar3_codecov, "0.4.0"}]}.
        # {provider_hooks, [{post, [{eunit, {codecov, analyze}}]}, {post, [{ct, {codecov, analyze}}]}]}.
        # {cover_enabled, true}.

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4 # Ou @v5 se for a recomendação mais atual
        if: success() && matrix.otp == '27.0' # Exemplo: enviar apenas para uma versão OTP
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: _build/test/codecov.json # Caminho para o relatório JSON gerado por rebar3_codecov analyze
          # ou use 'directory:./coverage' se gerar relatórios LCOV em um diretório específico
          fail_ci_if_error: true # Opcional: falhar o CI se o upload falhar
          verbose: true # Opcional

      # Opção 3: Upload para Coveralls (requer geração de LCOV)
      # - name: Generate LCOV report (exemplo, pode precisar de ferramenta externa)
      #   run: |
      #     # Comando para converter.coverdata para LCOV.
      #     # Exemplo: rebar3 covertool generate --lcov > coverage.lcov
      #     # Atualmente, rebar3 não tem um comando direto para LCOV.
      #     # Pode ser necessário um plugin como https://github.com/comtihon/rebar3_lcov
      #     # ou usar gcovr se os dados forem compatíveis.
      #     echo "Geração de LCOV não implementada nativamente por rebar3. Usar plugin ou ferramenta externa."
      #     # touch coverage.lcov # Placeholder
      #
      # - name: Upload coverage to Coveralls
      #   uses: coverallsapp/github-action@master
      #   if: success() && matrix.otp == '27.0' # Exemplo: enviar apenas para uma versão OTP
      #   with:
      #     github-token: ${{ secrets.GITHUB_TOKEN }}
      #     path-to-lcov: coverage.lcov # Caminho para o arquivo LCOV
      #     flag-name: OTP-${{ matrix.otp }} # Para diferenciar jobs de matriz no Coveralls
      #     parallel: ${{ strategy.matrix.otp!= '' }} # Marcar como paralelo se estiver em uma matriz

      - name: Upload test logs and HTML coverage report
        if: always() # Sempre fazer upload, mesmo se as etapas anteriores falharem
        uses: actions/upload-artifact@v4
        with:
          name: test-results-otp-${{ matrix.otp }}
          path: |
            _build/test/logs/ # Logs do Common Test
            _build/test/cover/ # Relatório HTML de cobertura do Rebar3
          if-no-files-found: warn # Avisar se não houver arquivos, mas não falhar
          retention-days: 7 # Manter artefatos por 7 dias